---
title: "Data Pre-Processing and Exponential Smoothing"
author: "Subhalaxmi Rout"
date: "06/14/2021"
output:
  word_document: default
  html_document:
    df_print: paged
subtitle: Week2 homework
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

```{r}
library(fpp2)
```

### Forecasting: Principles and Practices (Chapter 7 - Exponential smoothing)

#### 7.1

Consider the pigs series — the number of pigs slaughtered in Victoria each month.

**$(a)$ Use the ses() function in R to find the optimal values of**  
**$\alpha$ and  $\l_0$, and generate forecasts for the next four months.**

```{r}
model = ses(pigs)

fc <- model %>%
  forecast(h = 4)

summary(fc)

```

The optimal value of alpha = 0.2971 and Initial states = 77260.0561.

```{r}
autoplot(fc, series = "Data") +
  autolayer(fc$fitted, series="Fitted") +
  labs(y="# pigs", title="Pigs slaughtered in Victoria each month ", color = "Serise") +
  scale_color_manual(name="Series", 
                        values = c("Data"="gray50", 
                                   "Fitted"="orange"))
```

**$(b)$ Compute a 95% prediction interval for the first forecast using**  
**$\hat{y} ± 1.96s$ where  s is the standard deviation of the residuals. Compare** **your interval with the interval produced by R.**

```{r}
forecast <- 98816.41
s <- sd(fc$residuals)
y1 <-  forecast - 1.96 * s
print(y1)
y2 <-  forecast + 1.96 * s
print(y2)
```

95% prediction interval for the first forecast = (78679.97, 118952.8)

#### 7.2

**Write your own function to implement simple exponential smoothing. The function should take arguments y (the time series), alpha (the smoothing parameter**  
**α) and level (the initial level $\l_0$). It should return the forecast of the next observation in the series. Does it give the same forecast as ses()?**

To answer this question follow below approach:

* First create own time series
* apply `ses()` to calculate alpha, and initial value i.e l
* create own simple exponential smoothing function 
* Pass time series, alpha, and l as parameters
* compare forecast value by using `ses()` and own created `my_ses()`

```{r}
# time serise
myts <- ts(c(10,12,13, 14, 15, 2, 8, 36, 28, 12, 16, 22, 26, 23, 34, 11, 18, 19, 24, 5), frequency = 1)

# forecast for next observation
fc <- ses(myts) %>% forecast::forecast(h = 1)

# calculate alpha and l value
alpha <- fc$model$par[1]
print(alpha)
l <- fc$model$par[2]
print(l)

```

Created own ses function named `my_ses`. Pass the parameters to see the forecast and compair the result. 

```{r}
my_ses <- function(ts = myts, alpha = alpha, l = l){
  forecast <- l
  for(i in 1:length(myts)){
   forecast <- alpha*myts[i] + (1 - alpha)*forecast 
  }
  paste0("Forecast of next observation : ", forecast)
}

# user defined function
my_ses(ts = myts, alpha = alpha, l = l)

# Pre-defined function
fc
```

Yes, `my_ses()` function gives the same result as the `ses()`. 

#### 7.3

**Modify your function from the previous exercise to return the sum of squared errors rather than the forecast of the next observation. Then use the optim() function to find the optimal values of $\alpha$ and $\l_0$. Do you get the same values as the ses() function?**

```{r}
#myts

my_ses_err <- function(par = c(alpha, l), ts){
  err <- 0
  sse <- 0
  alpha <- par[1]
  l <- par[2]
  forecast <- l
  
  for(i in 1:length(ts)){
    err <- ts[i] - forecast
    sse <- sse + err ** 2
    
    forecast <- alpha*ts[i] + (1 - alpha)*forecast 
  }
  
  return(sse)
}

optimal_value <- optim(par = c(0.5, myts[1]), ts = myts, fn = my_ses_err)

paste0("Optimal value of alpha : ", optimal_value$par[1])
paste0("Optimal value of l : ", optimal_value$par[2])

```

Optimal value of alpha and l using `ses()`.

```{r}
paste0("Optimal value of alpha using ses() : ", fc$model$par[1])
paste0("Optimal value of l using ses() : ", fc$model$par[2])
```

The alpha value lies between 0 and 1 so anything below zero considers as 0. using `my_ses_err()` gets negative alpha values i.e zero. From `ses()` alpha value almost zero. The different optimal value getting for l. 

Get alpha value almost same but different l value. 

```{r}

```